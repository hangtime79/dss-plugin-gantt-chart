# Post-Mortem: v0.4.2

**Branch:** `feature/v0.4.2-debounce-and-sticky-header`
**Type:** Feature
**Duration:** 1 day (Started: 2025-12-23, Completed: 2025-12-23)
**Outcome:** âš ï¸ Partial Success

---

## Summary

Implemented configuration debouncing (fully successful) and sticky header via JavaScript scroll sync (partially successful). The debouncing feature works as designed. The sticky header works when chart content fills the viewport but exhibits jankiness when content is narrower than the viewport.

---

## Scope

### Planned
- [x] Configuration input debouncing (#15)
- [ ] Sticky header via JS scroll sync (#11)

### Delivered
- [x] Configuration debouncing - fully functional
- [x] View state preservation across config changes
- [x] Render overlap prevention
- [~] Sticky header - works with edge-to-edge content only

### Deferred Items
| Item | Reason | Target Version | Tracking |
|------|--------|----------------|----------|
| Sticky header narrow content fix | Browser paint/composite behavior issue beyond current scope | Future | #21 |

---

## Commit Analysis

| Metric | Value | Assessment |
|--------|-------|------------|
| Total commits | 11 | |
| Feature commits | 1 | |
| Fix/debug commits | 6 | |
| Docs commits | 4 | |
| Churn ratio | 55% | ðŸ”´ High (>40%) |

**High churn explanation:** This was a complex debugging effort involving 5 distinct implementation attempts. The sticky header problem proved to be caused by browser rendering behavior with narrow content, which was not discoverable without iterative testing.

---

## What Went Well

1. **Debouncing implementation:** Worked correctly from first attempt with minor refinements
2. **View state preservation:** Save/restore pattern worked well
3. **Console testing methodology:** User-assisted console testing quickly disproved the duplicate config message hypothesis
4. **Intervention documentation:** Detailed logging of each attempt enabled efficient handoff between sessions

---

## What Didn't Go Well

1. **Initial hypothesis was wrong:** Assumed Dataiku sent periodic config heartbeats (disproved via console test)
2. **Multiple fix attempts:** 5 attempts to fix sticky header, none fully successful
3. **Root cause discovery late:** Only discovered narrow content as the trigger after 4 attempts
4. **Optimization backfired:** The `lastStickyHeader` optimization added in Attempt 4 masked the Year view issue

---

## Blockers Encountered

| Blocker | Impact | Resolution | Time Lost |
|---------|--------|------------|-----------|
| Misidentified root cause | Wasted effort on config hash solution | Console testing disproved hypothesis | ~1 hour |
| Narrow content browser behavior | Could not fix sticky header completely | Documented as known limitation (#21) | ~2 hours |

---

## Technical Discoveries

### Platform Behavior
- Dataiku does NOT send periodic config heartbeat messages
- Dataiku sends "keep alive" messages every 10 seconds but these don't trigger config updates
- Config messages only fire on actual user changes

### Library Behavior
- Frappe Gantt creates very large SVGs (1.4M px for Hour view with 300+ tasks)
- `translate3d()` should be used for GPU acceleration, but doesn't fix all scroll issues

### Architecture Insights
- CSS `position: sticky` fails in Dataiku's nested iframe structure
- JavaScript transform-based sticky works but has edge cases with narrow content
- Browser compositor layer promotion may explain the "works after few minutes" behavior observed earlier

---

## CLI Docs Candidates

Items that should be added to CLAUDE.md:

1. **Dataiku config messaging:** Dataiku does not send periodic config heartbeats; only real changes trigger messages
2. **Sticky header limitation:** CSS sticky fails in iframe; JS transform works but has narrow content edge case

---

## Recommendations

### For Future Sticky Header Work (#21)
- Consider calculating minimum date range to ensure content always fills viewport
- Alternative: Use `position: fixed` with horizontal scroll sync (more complex)

### Process Improvements
- Console testing for hypothesis validation was effective - use earlier in debugging
- Break complex features into smaller, testable increments

### Technical Debt
- Test collection errors on main branch need investigation (unrelated to this work)

---

## Lessons Learned

1. **Validate hypotheses with data:** Console testing quickly disproved the duplicate config message assumption
2. **Browser rendering is complex:** Scroll-linked transforms behave differently based on content vs viewport dimensions
3. **Optimizations can hide bugs:** The `lastStickyHeader` optimization masked the Year view state corruption
4. **Document as you go:** The intervention log enabled efficient context transfer
5. **Know when to document limitations:** After 5 attempts, documenting as known limitation was the right call
