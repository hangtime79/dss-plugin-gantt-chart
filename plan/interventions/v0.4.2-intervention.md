# Intervention Log: v0.4.2 Debounce & Sticky Header

**Branch:** `feature/v0.4.2-debounce-and-sticky-header`
**Started:** 2025-12-23
**Status:** QA Round 3 Pending

---

## Issues Being Addressed

| Issue | Title | Priority |
|-------|-------|----------|
| #15 | Configuration input debouncing | Medium |
| #11 | Sticky header via JS scroll sync | Medium |

---

## Problem Statements

### Issue #15: Configuration Input Debouncing
**Symptom:** When users adjust numeric config inputs (e.g., Bar Height spinner), the chart re-renders for every single step (30 → 31 → 32 → 33), causing visual jank and scroll position jumps.

**Root Cause:** The Dataiku webapp framework sends config updates immediately on every input change. The `message` event listener calls `initializeChart()` immediately with no rate limiting.

### Issue #11: Sticky Header
**Symptom:** When scrolling vertically through a large task list, the timeline header scrolls out of view, making it hard to determine task dates.

**Root Cause:** CSS `position: sticky` fails due to nested scroll containers:
```
Dataiku iframe (overflow: auto)
  → #gantt-container (overflow: auto)
    → .gantt-container (overflow: auto)
      → .grid-header (sticky target - FAILS)
```

---

## Attempt History

### Attempt 1: Initial Implementation
**Commit:** `4e9cc8c feat(v0.4.2): Add config debouncing and sticky header`

**Approach:**
- **Debounce:** Added 500ms debounce timer around `initializeChart()` call
- **Sticky:** Added `setupStickyHeader()` function with transform-based scroll sync

**Code Changes:**
```javascript
// Debounce
configDebounceTimer = setTimeout(() => {
    initializeChart(webAppConfig, filters);
}, CONFIG_DEBOUNCE_MS);

// Sticky
container.addEventListener('scroll', function() {
    header.style.transform = `translateY(${container.scrollTop}px)`;
});
```

**QA Result:** ❌ FAILED
- Debounce: Triggered full refresh, reset view to default
- Sticky: Did nothing visible

---

### Attempt 2: Use update_options() Instead of Full Re-init
**Commit:** `40fed08 fix(v0.4.2): Fix debounce regression and improve sticky header`

**Approach:**
- **Debounce:** Use `ganttInstance.update_options()` instead of full `initializeChart()`
- **Sticky:** Track scroll handler, use solid background color

**Code Changes:**
```javascript
// Debounce with update_options
if (ganttInstance) {
    ganttInstance.update_options({
        bar_height: parseInt(webAppConfig.barHeight) || 30,
        // ... other visual options
    });
} else {
    initializeChart(webAppConfig, filters);
}
```

**QA Result:** ❌ FAILED
- Debounce: `update_options()` doesn't actually update visual properties like bar_height
- Sticky: Works in Year view but janky; breaks after view mode change

**Discovery:** `update_options()` is designed for certain options only, not visual properties like `bar_height`, `column_width`, etc.

---

### Attempt 3: Save/Restore View State Around Full Re-init
**Commit:** `667ce47 fix(v0.4.2): Fix debounce and sticky header issues (QA round 2)`

**Approach:**
- **Debounce:**
  - Go back to full `initializeChart()`
  - Save view mode + scroll position BEFORE re-init
  - Restore them AFTER render via `window._ganttRestoreState`
- **Sticky:**
  - Add `setupStickyHeader()` to `on_view_change` callback
  - Use `requestAnimationFrame` for smoother updates
  - Add `willChange: transform` for GPU acceleration

**Code Changes:**
```javascript
// Save state before re-init
if (ganttInstance) {
    savedViewMode = ganttInstance.options.view_mode;
    savedScrollLeft = container.scrollLeft;
    savedScrollTop = container.scrollTop;
}
window._ganttRestoreState = { viewMode, scrollLeft, scrollTop };
initializeChart(webAppConfig, filters);

// Restore after render (in renderGantt post-render block)
if (window._ganttRestoreState) {
    if (state.viewMode !== ganttInstance.options.view_mode) {
        ganttInstance.change_view_mode(state.viewMode);
    }
    container.scrollLeft = state.scrollLeft;
    container.scrollTop = state.scrollTop;
    window._ganttRestoreState = null;
}

// Sticky with rAF
stickyScrollHandler = function() {
    if (stickyAnimationFrame) cancelAnimationFrame(stickyAnimationFrame);
    stickyAnimationFrame = requestAnimationFrame(function() {
        header.style.transform = `translateY(${container.scrollTop}px)`;
    });
};

// Also added to on_view_change callback
on_view_change: function(mode) {
    requestAnimationFrame(() => {
        // ... other adjustments
        setupStickyHeader();  // Re-setup after view change
    });
}
```

**QA Result:** ❌ PARTIAL
- Debounce: View state preserved, BUT browser hung during rapid updates
- Sticky: Works after 60-90 sec, then stable; works across view changes

**Discovery:**
- Browser hang caused by overlapping async `initializeChart()` calls
- Sticky jankiness likely from repeated `setupStickyHeader()` during rapid config updates

---

### Attempt 4: Prevent Overlapping Renders + Simplify Sticky
**Commit:** `0540710 fix(v0.4.2): Prevent overlapping renders and simplify sticky (QA round 3)`

**Approach:**
- **Debounce:**
  - Add `renderInProgress` flag to prevent overlapping async renders
  - Skip debounced callback if render already in progress
  - Reset flag after render completes (and on error)
  - Reduce debounce from 500ms to 300ms
- **Sticky:**
  - Track header element reference to avoid redundant setup
  - Only re-register listener if DOM was actually recreated
  - Simplified scroll handler (removed rAF - direct transform)
  - Removed willChange hint

**Code Changes:**
```javascript
// New state
let renderInProgress = false;
let lastStickyHeader = null;

// In debounce callback
if (renderInProgress) {
    console.log('Render in progress, skipping');
    return;
}
renderInProgress = true;
initializeChart(webAppConfig, filters);

// After render completes
renderInProgress = false;

// Sticky - only setup if header changed
if (header === lastStickyHeader && stickyScrollHandler) {
    return; // Already set up
}
lastStickyHeader = header;
```

**QA Result:** ❌ PARTIAL
- Debounce: Better at higher levels, but Hour view slow (1.4M px SVG with 308 tasks)
- Debounce: Unexplained auto-refreshes happening
- Sticky: Still takes 90-210 seconds before working, then stable

**Discovery:**
- Hour view creates massive SVG (1,397,220px × 20,110px) - inherently expensive
- Dataiku may be sending periodic config "heartbeat" messages
- We treat every message as a change, causing unnecessary re-renders
- This explains both "refreshing for no reason" and sticky jankiness

---

### Attempt 5 (PROPOSED): Skip Duplicate Config Updates
**Status:** NOT YET IMPLEMENTED - Pending user verification of hypothesis

**Hypothesis:**
Dataiku sends config messages periodically (not just on user changes). We should:
1. Hash the config on each message
2. Compare to last hash
3. Only re-render if config actually changed

**Proposed Code:**
```javascript
let lastConfigHash = null;

function hashConfig(config) {
    const relevant = {
        dataset: config.dataset,
        barHeight: config.barHeight,
        columnWidth: config.columnWidth,
        // ... other rendering-relevant properties
    };
    return JSON.stringify(relevant);
}

// In message handler:
const newHash = hashConfig(webAppConfig);
if (newHash === lastConfigHash) {
    console.log('Config unchanged, skipping render');
    return;
}
lastConfigHash = newHash;
// ... proceed with debounce/render
```

**Console Test to Verify Hypothesis:**
Add this to browser console BEFORE the 90-210 second mark:
```javascript
// Intercept message events to see what Dataiku sends
window.addEventListener('message', function(e) {
    if (e.data && typeof e.data === 'string') {
        try {
            const d = JSON.parse(e.data);
            console.log('MSG:', new Date().toISOString(),
                        'keys:', Object.keys(d.webAppConfig || {}).length);
        } catch(x) {}
    }
}, true);
```

If you see repeated messages with the same content during the first 90-210 seconds, the hypothesis is confirmed.

**QA Result:** ⏳ PENDING VERIFICATION

---

## Current Implementation State

### Files Modified
| File | Changes |
|------|---------|
| `webapps/gantt-chart/app.js` | Debounce logic, setupStickyHeader(), restore state logic |
| `resource/webapp/style.css` | Updated sticky header CSS for JS control |
| `plugin.json` | Version 0.4.1.6 → 0.4.2 |
| `plan/specs/feature-v0.4.2-spec.md` | Spec file (now outdated - implementation diverged) |

### Current Code Flow

**On Config Change:**
1. Message event fires with new config
2. Debounce timer starts (500ms)
3. If timer expires without new config:
   - Save current view mode from `ganttInstance.options.view_mode`
   - Save scroll position from container
   - Store in `window._ganttRestoreState`
   - Call `initializeChart()`
4. In `renderGantt()` post-render:
   - If restore state exists:
     - Call `change_view_mode()` to restore view
     - Set `scrollLeft`/`scrollTop` to restore position
     - Clear restore state

**On Scroll (Sticky Header):**
1. Scroll event fires
2. Cancel any pending animation frame
3. Request new animation frame
4. In frame callback: set `header.style.transform = translateY(scrollTop)`

**On View Mode Change:**
1. User clicks view mode dropdown
2. Frappe Gantt handles the change internally
3. `on_view_change` callback fires
4. In callback: re-run `setupStickyHeader()` (DOM was recreated)

---

## Known Issues / Open Questions

1. **Sticky jankiness:** The transform approach may still be visually janky due to:
   - Paint/reflow cost of transform
   - Scroll event frequency
   - Possible alternative: Use IntersectionObserver or scroll snap

2. **Full re-init on every config change:** Even with save/restore, this is expensive. Consider:
   - Only re-init if data-affecting config changed (dataset, columns)
   - For visual-only changes, find a way to update DOM directly

3. **Spec file outdated:** The spec at `plan/specs/feature-v0.4.2-spec.md` no longer matches implementation. Should update after QA passes.

---

## QA Checklist

### Debouncing (#15)
- [ ] Adjust Bar Height spinner rapidly
- [ ] View mode preserved (not reset to default)
- [ ] Scroll position preserved
- [ ] Visual changes actually apply

### Sticky Header (#11)
- [ ] Header stays visible during vertical scroll
- [ ] Smooth scrolling (not janky)
- [ ] Persists after view mode change
- [ ] Horizontal scroll still works normally

### Regression
- [ ] View mode transitions work
- [ ] Today button works
- [ ] Header labels adjust correctly
- [ ] Date boundaries still work

---

## Commits

| Hash | Message |
|------|---------|
| `4e9cc8c` | feat(v0.4.2): Add config debouncing and sticky header (#15, #11) |
| `40fed08` | fix(v0.4.2): Fix debounce regression and improve sticky header |
| `667ce47` | fix(v0.4.2): Fix debounce and sticky header issues (QA round 2) |
| `dfed8db` | docs(v0.4.2): Add intervention log tracking all attempts |
| `0540710` | fix(v0.4.2): Prevent overlapping renders and simplify sticky (QA round 3) |

---

## Next Steps

### Immediate (Attempt 5)
1. **Verify hypothesis:** Run the console test to confirm Dataiku sends repeated config messages
2. **If confirmed:** Implement config hash comparison to skip duplicate updates
3. **If not confirmed:** Look for other sources of spurious re-renders

### If Attempt 5 Succeeds
- Both issues should be resolved:
  - No more "refreshing for no reason"
  - Sticky works immediately (no 90-210 sec delay)
  - Hour view still slow but that's inherent to 1.4M px SVG

### If Attempt 5 Fails
1. **For sticky:** Consider position:fixed approach with horizontal scroll sync
2. **For debounce:** Add visual loading state during expensive re-renders
3. **For Hour view:** Consider lazy rendering or virtual scrolling (major refactor)

### Recovery Notes (for context compaction)
If context is compacted, read this file for:
- Full history of 5 attempts
- Current hypothesis about duplicate config messages
- Console test to verify hypothesis
- Proposed fix code

Key files:
- `webapps/gantt-chart/app.js` - main logic
- `resource/webapp/style.css` - CSS for sticky (currently JS-controlled)
- `plan/interventions/v0.4.2-intervention.md` - this file
