# Intervention Log: v0.4.2 Debounce & Sticky Header

**Branch:** `feature/v0.4.2-debounce-and-sticky-header`
**Started:** 2025-12-23
**Status:** QA Round 3 Pending

---

## Issues Being Addressed

| Issue | Title | Priority |
|-------|-------|----------|
| #15 | Configuration input debouncing | Medium |
| #11 | Sticky header via JS scroll sync | Medium |

---

## Problem Statements

### Issue #15: Configuration Input Debouncing
**Symptom:** When users adjust numeric config inputs (e.g., Bar Height spinner), the chart re-renders for every single step (30 → 31 → 32 → 33), causing visual jank and scroll position jumps.

**Root Cause:** The Dataiku webapp framework sends config updates immediately on every input change. The `message` event listener calls `initializeChart()` immediately with no rate limiting.

### Issue #11: Sticky Header
**Symptom:** When scrolling vertically through a large task list, the timeline header scrolls out of view, making it hard to determine task dates.

**Root Cause:** CSS `position: sticky` fails due to nested scroll containers:
```
Dataiku iframe (overflow: auto)
  → #gantt-container (overflow: auto)
    → .gantt-container (overflow: auto)
      → .grid-header (sticky target - FAILS)
```

---

## Attempt History

### Attempt 1: Initial Implementation
**Commit:** `4e9cc8c feat(v0.4.2): Add config debouncing and sticky header`

**Approach:**
- **Debounce:** Added 500ms debounce timer around `initializeChart()` call
- **Sticky:** Added `setupStickyHeader()` function with transform-based scroll sync

**Code Changes:**
```javascript
// Debounce
configDebounceTimer = setTimeout(() => {
    initializeChart(webAppConfig, filters);
}, CONFIG_DEBOUNCE_MS);

// Sticky
container.addEventListener('scroll', function() {
    header.style.transform = `translateY(${container.scrollTop}px)`;
});
```

**QA Result:** ❌ FAILED
- Debounce: Triggered full refresh, reset view to default
- Sticky: Did nothing visible

---

### Attempt 2: Use update_options() Instead of Full Re-init
**Commit:** `40fed08 fix(v0.4.2): Fix debounce regression and improve sticky header`

**Approach:**
- **Debounce:** Use `ganttInstance.update_options()` instead of full `initializeChart()`
- **Sticky:** Track scroll handler, use solid background color

**Code Changes:**
```javascript
// Debounce with update_options
if (ganttInstance) {
    ganttInstance.update_options({
        bar_height: parseInt(webAppConfig.barHeight) || 30,
        // ... other visual options
    });
} else {
    initializeChart(webAppConfig, filters);
}
```

**QA Result:** ❌ FAILED
- Debounce: `update_options()` doesn't actually update visual properties like bar_height
- Sticky: Works in Year view but janky; breaks after view mode change

**Discovery:** `update_options()` is designed for certain options only, not visual properties like `bar_height`, `column_width`, etc.

---

### Attempt 3: Save/Restore View State Around Full Re-init
**Commit:** `667ce47 fix(v0.4.2): Fix debounce and sticky header issues (QA round 2)`

**Approach:**
- **Debounce:**
  - Go back to full `initializeChart()`
  - Save view mode + scroll position BEFORE re-init
  - Restore them AFTER render via `window._ganttRestoreState`
- **Sticky:**
  - Add `setupStickyHeader()` to `on_view_change` callback
  - Use `requestAnimationFrame` for smoother updates
  - Add `willChange: transform` for GPU acceleration

**Code Changes:**
```javascript
// Save state before re-init
if (ganttInstance) {
    savedViewMode = ganttInstance.options.view_mode;
    savedScrollLeft = container.scrollLeft;
    savedScrollTop = container.scrollTop;
}
window._ganttRestoreState = { viewMode, scrollLeft, scrollTop };
initializeChart(webAppConfig, filters);

// Restore after render (in renderGantt post-render block)
if (window._ganttRestoreState) {
    if (state.viewMode !== ganttInstance.options.view_mode) {
        ganttInstance.change_view_mode(state.viewMode);
    }
    container.scrollLeft = state.scrollLeft;
    container.scrollTop = state.scrollTop;
    window._ganttRestoreState = null;
}

// Sticky with rAF
stickyScrollHandler = function() {
    if (stickyAnimationFrame) cancelAnimationFrame(stickyAnimationFrame);
    stickyAnimationFrame = requestAnimationFrame(function() {
        header.style.transform = `translateY(${container.scrollTop}px)`;
    });
};

// Also added to on_view_change callback
on_view_change: function(mode) {
    requestAnimationFrame(() => {
        // ... other adjustments
        setupStickyHeader();  // Re-setup after view change
    });
}
```

**QA Result:** ⏳ PENDING

---

## Current Implementation State

### Files Modified
| File | Changes |
|------|---------|
| `webapps/gantt-chart/app.js` | Debounce logic, setupStickyHeader(), restore state logic |
| `resource/webapp/style.css` | Updated sticky header CSS for JS control |
| `plugin.json` | Version 0.4.1.6 → 0.4.2 |
| `plan/specs/feature-v0.4.2-spec.md` | Spec file (now outdated - implementation diverged) |

### Current Code Flow

**On Config Change:**
1. Message event fires with new config
2. Debounce timer starts (500ms)
3. If timer expires without new config:
   - Save current view mode from `ganttInstance.options.view_mode`
   - Save scroll position from container
   - Store in `window._ganttRestoreState`
   - Call `initializeChart()`
4. In `renderGantt()` post-render:
   - If restore state exists:
     - Call `change_view_mode()` to restore view
     - Set `scrollLeft`/`scrollTop` to restore position
     - Clear restore state

**On Scroll (Sticky Header):**
1. Scroll event fires
2. Cancel any pending animation frame
3. Request new animation frame
4. In frame callback: set `header.style.transform = translateY(scrollTop)`

**On View Mode Change:**
1. User clicks view mode dropdown
2. Frappe Gantt handles the change internally
3. `on_view_change` callback fires
4. In callback: re-run `setupStickyHeader()` (DOM was recreated)

---

## Known Issues / Open Questions

1. **Sticky jankiness:** The transform approach may still be visually janky due to:
   - Paint/reflow cost of transform
   - Scroll event frequency
   - Possible alternative: Use IntersectionObserver or scroll snap

2. **Full re-init on every config change:** Even with save/restore, this is expensive. Consider:
   - Only re-init if data-affecting config changed (dataset, columns)
   - For visual-only changes, find a way to update DOM directly

3. **Spec file outdated:** The spec at `plan/specs/feature-v0.4.2-spec.md` no longer matches implementation. Should update after QA passes.

---

## QA Checklist

### Debouncing (#15)
- [ ] Adjust Bar Height spinner rapidly
- [ ] View mode preserved (not reset to default)
- [ ] Scroll position preserved
- [ ] Visual changes actually apply

### Sticky Header (#11)
- [ ] Header stays visible during vertical scroll
- [ ] Smooth scrolling (not janky)
- [ ] Persists after view mode change
- [ ] Horizontal scroll still works normally

### Regression
- [ ] View mode transitions work
- [ ] Today button works
- [ ] Header labels adjust correctly
- [ ] Date boundaries still work

---

## Commits

| Hash | Message |
|------|---------|
| `4e9cc8c` | feat(v0.4.2): Add config debouncing and sticky header (#15, #11) |
| `40fed08` | fix(v0.4.2): Fix debounce regression and improve sticky header |
| `667ce47` | fix(v0.4.2): Fix debounce and sticky header issues (QA round 2) |

---

## Next Steps If QA Fails

1. **If debounce still resets view:**
   - Add console.log to verify `savedViewMode` is captured correctly
   - Check if `change_view_mode()` is being called in restore
   - Consider using a different restore mechanism

2. **If sticky still janky:**
   - Try using CSS `translate3d` for hardware acceleration
   - Consider position:fixed approach with horizontal scroll sync
   - Research if there's a better pattern for this scenario

3. **If sticky breaks after view change:**
   - Verify `setupStickyHeader()` is being called in `on_view_change`
   - Check if DOM element reference is correct after re-render
